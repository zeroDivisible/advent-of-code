exit
fabric
e
exit
c
exit
overlapping.to_a - input.map(&:first)
input.map(&:first)
overlapping
n
overlapping
n
row.select { |n| n.length > 1 }
n
row
n
el
row
n
s
row
c
row
c
row
ro
c
n
c
overlapping
n
overlapping
el
c
n
exit
input.map(&:first)
a << *['a', 'b']
a << *['a', 'b'].flatten
a << ['a', 'b'].flatten
a << ['a', 'b']
a =Set.new
Set.new(row.select { |n| n.length == 1 }.flatten)
Set.new(row.select { |n| n.length == 1 })
require 'set'
row
row.select { |n| n.length == 1 }
n
fabric
puts fabric
fabric
exit
row
n
c
row.select { |n| n.length == 1 }
n
row.select { |n| n.length == 1 }
c
sum
n
exit
 fabric[row][column]
 fabric[row][column] <<id
id
 fabric[row][column] = fabric[row][column] + id
 fabric[row][column]
exit
c
 row.select { |n| n > 1 }.inject(0, :+)
 row.select { |n| n > 1 }.inject(0)
 row.select { |n| n > 1 }.inject
 row.select { |n| n > 1 }.inject(0)
n
c
row.select { |n| n > 1 }
n
row
c
n
line
s
n
exit
input[0]
line
height
width
top
left
n
s
n
exit
[0,0,1,1,2,2,1].select { |n| n > 1 }.reduce(:+)
[0,0,1,1,2,2,1].select { |n| n > 1 }
(0...4).each { |l| puts l }
(0..4).each { |l| puts l }
(0..3).each { |l| puts l }
fabric[0][0]
n
input[0]
n
